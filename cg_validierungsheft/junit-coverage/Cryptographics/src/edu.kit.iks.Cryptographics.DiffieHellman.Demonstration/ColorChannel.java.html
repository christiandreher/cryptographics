<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ColorChannel.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">test (Mar 21, 2014 6:54:09 PM)</a> &gt; <a href="../../index.html" class="el_group">Cryptographics</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">edu.kit.iks.Cryptographics.DiffieHellman.Demonstration</a> &gt; <span class="el_source">ColorChannel.java</span></div><h1>ColorChannel.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">package edu.kit.iks.Cryptographics.DiffieHellman.Demonstration;</span>

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;

import javax.swing.JPanel;
import javax.swing.Timer;

import org.xnap.commons.i18n.I18n;

import edu.kit.iks.Cryptographics.DiffieHellman.Model;
import edu.kit.iks.CryptographicsLib.Configuration;
import edu.kit.iks.CryptographicsLib.Logger;

/**
 * This is the visual Communication Channel for
 * the Diffie-Hellman Key-Exchange Analogy.
 * In this JPanel we exchange colored circles and compute
 * a shared secret similar like in real DH-KE
 * 
 *  @author kai
 */

<span class="nc bnc" id="L31" title="All 2 branches missed.">public class ColorChannel extends JPanel {</span>

	private static final long serialVersionUID = 4073013433018353584L;

	/**
	 * Localization instance
	 */
<span class="nc" id="L38">	private static I18n i18n = Configuration.getInstance().getI18n(ColorChannel.class);</span>
	
	/**
	 * remembers the colors of alice,bob,eve
	 */
	private Model model;
	
	/**
	 * This views are used for mixing the shared secrets of alice and bob
	 */
	private ColorMix cm1, cm2;
	
	/**
	 * we use this as a container for cm1 and cm2
	 */
	private JPanel container;
	
	/** the coordinates of the circles */
	private int x1, y1, x2, y2;
	
	/** the x coordinates for the communications lines */
	private int leftEnd, rightEnd, middle;
	
	/** the y coordinates for the communications lines 
	 * middleCircle and rightCircle are basically
	 * the same like middle and rightEnd but corrected
	 * by the size of the circles */
	private int lowerEnd, upperEnd, middleCircle, rightCircle;
	
	/**
	 * the original coordinate values
	 */
	private int originalx1, originaly1, originalx2, originaly2;
	
	/** kept colors are drawn to the screen*/
	private ArrayList&lt;Ellipse2DwithLabel&gt; keptColors;
	
	/** those are used for sending over the channel */
	private Ellipse2DwithColor ellip, ellip2;
	
	/** the circles that are displayed next to alice, bob and eve,
	 * need to know how many each one has */
	private int[] numOfCircles;
	
	/** the color to send next */
<span class="nc" id="L83">	private Color colorNextToSend = Color.BLACK;</span>
	
	/** the color of the channel, that means the lines */
<span class="nc" id="L86">	private Color channelColor = Color.BLACK;</span>
	
	/** is this the firstCall of the sendMethod,
	 * first means the first timer event
	 */
	private boolean firstTimerEventAlice, firstTimerEventBob;

	/** repeat the sending of the color
	 * if true
	 */
	private boolean repeatPeriodically;

	/** diameter of the ellipses2d circles */
<span class="nc" id="L99">	private int circleSize = 50;</span>
	
	/** while sending these values will be true */
	private boolean sendAlice, sendBob;
	
	/** when true, all received colors will still
	 * be drawn next to the receivers, so that we
	 * know which person  got which color */
	private boolean keepCircles;
	
	/**
	 * used for firing timer evers to update the coordinates etc.
	 */
	private Timer timer;
	
	/** how quick shall the timer event be fired */
<span class="nc" id="L115">	private int timerInterval = 40;</span>

	/**
	 * Constructor takes the size of JPanel, and
	 * the size of the circles. From there
	 * it computes the position for the communication
	 * channel and plot everything correctly
	 * 
	 * @param d the size of JPanel
	 * @param circleSize the diameter of the circles
	 */
<span class="nc" id="L126">	public ColorChannel(Dimension d, int circleSize) {</span>
<span class="nc" id="L127">		container = new JPanel();</span>
<span class="nc" id="L128">		container.setSize(new Dimension((int)d.getWidth(), (int)d.getHeight()/3));</span>
<span class="nc" id="L129">		container.setPreferredSize(new Dimension((int)d.getWidth(), (int)d.getHeight()/3));</span>
<span class="nc" id="L130">		this.cm1 = new ColorMix(circleSize, new Dimension((int)d.getWidth()/2, (int)d.getHeight()/4));</span>
<span class="nc" id="L131">		this.cm2 = new ColorMix(circleSize, new Dimension((int)d.getWidth()/2, (int)d.getHeight()/4));</span>
<span class="nc" id="L132">		this.setLayout(new BorderLayout());</span>
<span class="nc" id="L133">		container.add(cm1);</span>
<span class="nc" id="L134">		container.add(cm2);</span>
<span class="nc" id="L135">		this.add(container, BorderLayout.SOUTH);</span>
<span class="nc" id="L136">		this.model = new Model();</span>
<span class="nc" id="L137">		this.setSize(d);</span>
<span class="nc" id="L138">		this.setPreferredSize(d);</span>
<span class="nc" id="L139">		this.circleSize = circleSize;</span>
<span class="nc" id="L140">		this.leftEnd = (int) (0.25*this.getWidth());</span>
<span class="nc" id="L141">		this.rightEnd = (int) (0.75*this.getWidth());</span>
<span class="nc" id="L142">		this.lowerEnd = (int) (0.75*this.getHeight());</span>
<span class="nc" id="L143">		this.upperEnd = (int) (0.25*this.getHeight());</span>
<span class="nc" id="L144">		this.rightCircle = rightEnd-circleSize;</span>
<span class="nc" id="L145">		this.originalx1 = leftEnd;</span>
<span class="nc" id="L146">		this.originaly1 = lowerEnd-circleSize/2;</span>
<span class="nc" id="L147">		this.middle = (leftEnd+rightEnd)/2;</span>
<span class="nc" id="L148">		this.middleCircle = this.middle-circleSize/2;</span>
<span class="nc" id="L149">		this.originalx2 = this.middle-circleSize/2;</span>
<span class="nc" id="L150">		this.originaly2 = lowerEnd-circleSize/2;</span>
<span class="nc" id="L151">		this.x1 = originalx1;</span>
<span class="nc" id="L152">		this.y1 = originaly1;</span>
<span class="nc" id="L153">		this.x2 = originalx2;</span>
<span class="nc" id="L154">		this.y2 = originaly2;</span>
<span class="nc" id="L155">		this.firstTimerEventAlice = true;</span>
<span class="nc" id="L156">		this.firstTimerEventBob = true;</span>
<span class="nc" id="L157">		this.numOfCircles = new int[3];</span>
<span class="nc" id="L158">		this.keptColors = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L159">		ellip = new Ellipse2DwithColor(x1, y1, circleSize, circleSize);</span>
<span class="nc" id="L160">		ellip2 = new Ellipse2DwithColor(x2, y2, circleSize, circleSize);</span>
<span class="nc" id="L161">	}</span>
	
	/*
	 * here we'll draw the circles and the communication lines
	 */
	@Override
	protected void paintComponent(Graphics g) {
<span class="nc" id="L168">		Graphics2D g2 = (Graphics2D) g;</span>
<span class="nc" id="L169">		super.paintComponent(g);</span>
<span class="nc" id="L170">		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L171">		g2.setPaint(channelColor);</span>
		
<span class="nc" id="L173">		drawChannel(g2, this.leftEnd, this.rightEnd, this.lowerEnd, this.upperEnd);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">		for(Ellipse2DwithColor circle : keptColors) {</span>
<span class="nc" id="L175">			paintCircle(g2, circle);</span>
		}
<span class="nc bnc" id="L177" title="All 2 branches missed.">		if (sendAlice) {</span>
			
<span class="nc" id="L179">			ellip.setFrame(x1, y1, circleSize, circleSize);</span>
<span class="nc" id="L180">			paintCircle(g2, ellip);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">			if(x1 &lt; this.middleCircle) {</span>
<span class="nc" id="L182">				ellip2.setFrame(x2, y2, circleSize, circleSize);</span>
<span class="nc" id="L183">				paintCircle(g2, ellip2);</span>
			}
<span class="nc bnc" id="L185" title="All 2 branches missed.">		} else if (sendBob) {</span>
<span class="nc" id="L186">			ellip.setFrame(x1, y1, circleSize, circleSize);</span>
<span class="nc" id="L187">			paintCircle(g2, ellip);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			if(x1 &gt; this.middleCircle) {</span>
<span class="nc" id="L189">				ellip2.setFrame(x2, y2, circleSize, circleSize);</span>
<span class="nc" id="L190">				paintCircle(g2, ellip2);</span>
			}
			
		}
		
<span class="nc" id="L195">	}</span>

	private void paintCircle(Graphics2D g, Ellipse2DwithColor circle) {
<span class="nc bnc" id="L198" title="All 2 branches missed.">		if(circle instanceof Ellipse2DwithLabel) {</span>
//			g.setStroke(new BasicStroke());
<span class="nc" id="L200">			g.setColor(Color.BLACK);</span>
<span class="nc" id="L201">			g.drawString(((Ellipse2DwithLabel) circle).getLabel(), (int) circle.getX(), (int) circle.getY());</span>
		}
<span class="nc" id="L203">		g.setColor(circle.getColor());</span>
<span class="nc" id="L204">		g.fill(circle);</span>
<span class="nc" id="L205">		return;</span>
	}

	/* 
	 * draw the communication channels, that means the lines that
	 * represents those
	 */
	private void drawChannel(Graphics2D g2, int x1, int x2, int x3, int x4) {
<span class="nc" id="L213">		g2.drawLine(x1, x3, x2, x3);</span>
<span class="nc" id="L214">		g2.drawLine((x1+x2)/2, x4, (x1+x2)/2, x3);</span>
<span class="nc" id="L215">		g2.drawString(i18n.tr(&quot;Alice&quot;), x1-50, x3);</span>
<span class="nc" id="L216">		g2.drawString(i18n.tr(&quot;Bob&quot;), x2+10, x3);</span>
<span class="nc" id="L217">		g2.drawString(i18n.tr(&quot;Eve&quot;), (x1+x2)/2 - 15, x4-10);</span>
<span class="nc" id="L218">	}</span>
	
	/**
	 * send a color previously set to Bob
	 * @param cb the step that should be called when this method is finished
	 * @param keepFirst do we want to show the sent color after this method is finished
	 */
	public void sendToBob(final NextStepCallback cb, final boolean keepFirst, final String label) {
<span class="nc bnc" id="L226" title="All 2 branches missed.">		if(sendAlice) {</span>
			/* don't want to send colors
			 * if others are being send
			 */
<span class="nc" id="L230">			return;</span>
		}
<span class="nc" id="L232">		this.sendBob = true;</span>
<span class="nc" id="L233">		this.ellip.setColor(this.colorNextToSend);</span>
<span class="nc" id="L234">		this.ellip2.setColor(this.colorNextToSend);</span>
<span class="nc" id="L235">		this.x1 = this.leftEnd;</span>
<span class="nc" id="L236">		this.x2 = this.middleCircle;</span>
<span class="nc" id="L237">		this.y2 = this.originaly2;</span>
<span class="nc" id="L238">		timer = new Timer(timerInterval, new ActionListener() {</span>
			
			@Override
			public void actionPerformed(ActionEvent arg0) {
<span class="nc" id="L242">				Logger.debug(this.getClass().getName(),&quot;sendToBob&quot; , &quot;timer event&quot;);</span>
<span class="nc bnc" id="L243" title="All 6 branches missed.">				if(firstTimerEventBob &amp;&amp; !repeatPeriodically &amp;&amp; keepFirst) {</span>
<span class="nc" id="L244">					chooseColorToKeep(colorNextToSend, 0, label);</span>
<span class="nc" id="L245">					firstTimerEventBob = false;</span>
				}
<span class="nc bnc" id="L247" title="All 2 branches missed.">				if(x1 &lt; rightCircle) {</span>
<span class="nc" id="L248">					x1 += 3;</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">					if (x1 &gt; middleCircle &amp;&amp; y2 &gt; upperEnd) {</span>
<span class="nc" id="L250">						y2 -= 3;</span>
					}
<span class="nc" id="L252">				} else {</span>
<span class="nc" id="L253">					sendBob = false;</span>
<span class="nc" id="L254">					firstTimerEventBob = true;</span>
<span class="nc" id="L255">					timer.stop();</span>
<span class="nc bnc" id="L256" title="All 4 branches missed.">					if(keepCircles &amp;&amp; !repeatPeriodically) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">						for(int i=1; i &lt; 3; i++) {</span>
<span class="nc" id="L258">							chooseColorToKeep(colorNextToSend, i, label);</span>
						}
					}
<span class="nc bnc" id="L261" title="All 2 branches missed.">					if(cb != null) {</span>
<span class="nc" id="L262">						cb.callback();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">					} else if (repeatPeriodically) {</span>
<span class="nc" id="L264">						Logger.debug(this.getClass().getName(), &quot;&quot;, &quot;repeat now&quot;);</span>
						// set to orignal values, to start all over
<span class="nc" id="L266">						sendBob = true;</span>
<span class="nc" id="L267">						x1 = leftEnd;</span>
<span class="nc" id="L268">						x2 = middleCircle;</span>
<span class="nc" id="L269">						y2 = originaly2;</span>
<span class="nc" id="L270">						timer.restart();</span>
					}
				}
<span class="nc" id="L273">				repaint();</span>
<span class="nc" id="L274">			}</span>
		});
<span class="nc" id="L276">		timer.start();</span>
<span class="nc" id="L277">	}</span>
	
	/**
	 * send a color previously set to Alice
	 * @param cb the step that should be called when this method is finished
	 * @param keepFirst do we want to show the sent color after this method is finished
	 */
	public void sendToAlice(final NextStepCallback cb, final boolean keepFirst, final String label) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">		if(sendBob) {</span>
			/* don't want to send if there
			 * is already colors to be sent
			 */
<span class="nc" id="L289">			return;</span>
		}
<span class="nc" id="L291">		this.sendAlice = true;</span>
<span class="nc" id="L292">		this.ellip.setColor(this.colorNextToSend);</span>
<span class="nc" id="L293">		this.ellip2.setColor(this.colorNextToSend);</span>
<span class="nc" id="L294">		this.x1 = this.rightCircle;</span>
<span class="nc" id="L295">		this.x2 = this.middleCircle;</span>
<span class="nc" id="L296">		this.y2 = this.originaly2;</span>
<span class="nc" id="L297">		timer = new Timer(timerInterval, new ActionListener() {</span>
			
			@Override
			public void actionPerformed(ActionEvent arg0) {
<span class="nc" id="L301">				Logger.debug(this.getClass().getName(),&quot;sendToAlice&quot; , &quot;timer event&quot;);</span>
<span class="nc bnc" id="L302" title="All 6 branches missed.">				if(firstTimerEventAlice &amp;&amp; !repeatPeriodically &amp;&amp; keepFirst) {</span>
<span class="nc" id="L303">					chooseColorToKeep(colorNextToSend, 1, label);</span>
<span class="nc" id="L304">					firstTimerEventAlice = false;</span>
				}
<span class="nc bnc" id="L306" title="All 2 branches missed.">				if(x1 &gt; leftEnd) {</span>
<span class="nc" id="L307">					x1 -= 3;</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">					if (x1 &lt; middleCircle &amp;&amp; y2 &gt; upperEnd) {</span>
<span class="nc" id="L309">						y2 -= 3;</span>
					}
<span class="nc" id="L311">				} else {</span>
<span class="nc" id="L312">					sendAlice = false;</span>
<span class="nc" id="L313">					firstTimerEventAlice = true;</span>
<span class="nc" id="L314">					timer.stop();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">					if(keepCircles) {</span>
<span class="nc" id="L316">						chooseColorToKeep(colorNextToSend, 0, label);</span>
<span class="nc" id="L317">						chooseColorToKeep(colorNextToSend, 2, label);</span>
					}
<span class="nc bnc" id="L319" title="All 2 branches missed.">					if(cb != null) {</span>
<span class="nc" id="L320">						cb.callback();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">					} else if (repeatPeriodically) {</span>
<span class="nc" id="L322">						Logger.debug(this.getClass().getName(), &quot;&quot;, &quot;repeat now&quot;);</span>
						// set to orignal values, to start all over
<span class="nc" id="L324">						sendAlice = true;</span>
<span class="nc" id="L325">						x1 = rightCircle;</span>
<span class="nc" id="L326">						x2 = middleCircle;</span>
<span class="nc" id="L327">						y2 = originaly2;</span>
<span class="nc" id="L328">						timer.restart();</span>
					}
				}
<span class="nc" id="L331">				repaint();</span>
<span class="nc" id="L332">			}</span>
		});
<span class="nc" id="L334">		timer.start();</span>
<span class="nc" id="L335">	}</span>
	
	/*
	 * compute the horizontal position of the next circle to add
	 * to alice/bob/eve
	 */
	private int computeXCoordinate(int numOfKeptColors, int who) {
<span class="nc bnc" id="L342" title="All 4 branches missed.">		switch(who) {</span>
		case 0:
			//alice
<span class="nc" id="L345">			return leftEnd-numOfKeptColors*circleSize;</span>
		case 1:
			//bob
<span class="nc" id="L348">			return rightCircle+numOfKeptColors*circleSize;</span>
		case 2:
			//eve
<span class="nc" id="L351">			return middleCircle+(numOfKeptColors+1)*circleSize;</span>
		}
		//error
<span class="nc" id="L354">		return -1;</span>
	}
	
	/*
	 * copmute the vertical position of the next circle to add
	 * to alice/bob/eve
	 */
	private int computeYCoordinate(int numOfKeptColors, int who) {
<span class="nc bnc" id="L362" title="All 3 branches missed.">		switch(who) {</span>
		case 0:
		case 1:
			//alice
			//bob
<span class="nc" id="L367">			return lowerEnd+circleSize/2;</span>
		case 2:
			//eve
<span class="nc" id="L370">			return upperEnd-circleSize/2;</span>
		}
		//error
<span class="nc" id="L373">		return -1;</span>
	}
	
	/**
	 * add a kept circle to alice/bob/eve
	 * @param color the color of the circle to keep
	 * @param who alice, bob or eve
	 */
	public void chooseColorToKeep(Color color, int who, String label) {
<span class="nc" id="L382">		this.keptColors.add(new Ellipse2DwithLabel(computeXCoordinate(numOfCircles[who], who), computeYCoordinate(numOfCircles[who], who), circleSize, circleSize, color, label));</span>
<span class="nc" id="L383">		this.numOfCircles[who]++;</span>
<span class="nc" id="L384">		repaint();</span>
<span class="nc" id="L385">	}</span>

	/**
	 * we need to stop the timer when we unload the view,
	 * since garbage collector won't do that
	 * for us
	 */
	public void stopTimer() {
<span class="nc bnc" id="L393" title="All 2 branches missed.">		if(timer != null) {</span>
<span class="nc" id="L394">			timer.stop();</span>
		}
<span class="nc" id="L396">	}</span>

	/**
	 * basically does the same like in the constructor
	 * used if size of jpanel was changed
	 */
	public void loadView() {
<span class="nc" id="L403">		this.leftEnd = (int) (0.25*this.getWidth());</span>
<span class="nc" id="L404">		this.rightEnd = (int) (0.75*this.getWidth());</span>
<span class="nc" id="L405">		this.lowerEnd = (int) (0.75*this.getHeight());</span>
<span class="nc" id="L406">		this.upperEnd = (int) (0.25*this.getHeight());</span>
<span class="nc" id="L407">		this.rightCircle = rightEnd-circleSize;</span>
<span class="nc" id="L408">		this.originalx1 = leftEnd;</span>
<span class="nc" id="L409">		this.originaly1 = lowerEnd-circleSize/2;</span>
<span class="nc" id="L410">		this.middle = (leftEnd+rightEnd)/2;</span>
<span class="nc" id="L411">		this.middleCircle = this.middle-circleSize/2;</span>
<span class="nc" id="L412">		this.originalx2 = this.middle-circleSize/2;</span>
<span class="nc" id="L413">		this.originaly2 = lowerEnd-circleSize/2;</span>
<span class="nc" id="L414">		this.x1 = originalx1;</span>
<span class="nc" id="L415">		this.y1 = originaly1;</span>
<span class="nc" id="L416">		this.x2 = originalx2;</span>
<span class="nc" id="L417">		this.y2 = originaly2;</span>
<span class="nc" id="L418">		ellip.setFrame(x1, y1, circleSize, circleSize);</span>
<span class="nc" id="L419">		ellip2.setFrame(x2, y2, circleSize, circleSize);</span>
<span class="nc" id="L420">	}</span>
	
	/**
	 * the public color, this is the color
	 * send when sendPublicColor is called
	 * @param color the color we'll set the public to
	 */
	public void choosePublicColor(Color color) {
<span class="nc" id="L428">		this.model.setPublicColor(color);</span>
<span class="nc" id="L429">	}</span>
	
	/**
	 * chooses alices private color, and adds
	 * it to the kept colors
	 * @param color alices new private color
	 */
	public void chooseAlicePrivateColor(Color color) {
<span class="nc" id="L437">		this.model.setAlicePrivateColor(color);</span>
<span class="nc" id="L438">		this.chooseColorToKeep(color, 0, &quot;SA&quot;);</span>
<span class="nc" id="L439">	}</span>
	
	/**
	 * chooses bobs private color, and adds
	 * it to the kept colors
	 * @param color bobs new private color
	 */
	public void chooseBobPrivateColor(Color color) {
<span class="nc" id="L447">		this.model.setBobPrivateColor(color);</span>
<span class="nc" id="L448">		this.chooseColorToKeep(color, 1, &quot;SB&quot;);</span>
<span class="nc" id="L449">	}</span>
	
	/**
	 * compute alices mixed color
	 */
	public void mixAlicePrivatePublic() {
<span class="nc" id="L455">		this.model.mixAlicePrivateAndPublic();</span>
<span class="nc" id="L456">	}</span>
	
	/**
	 * compute bobs mixed color
	 */
	public void mixBobPrivatePublic() {
<span class="nc" id="L462">		this.model.mixBobPrivateAndPublic();</span>
<span class="nc" id="L463">	}</span>
	
	/**
	 * send the public color to bob
	 * @param cb our callback to call, when finished
	 */
	public void sendPublicColor(NextStepCallback cb) {
<span class="nc" id="L470">		this.setColorNextToSend(this.model.getPublicColor());</span>
<span class="nc" id="L471">		this.sendToBob(cb, true, &quot;P&quot;);</span>
<span class="nc" id="L472">	}</span>
	
	/**
	 * send alice mixed color to bob
	 * @param cb our callback to call, when finished
	 */
	public void sendAliceMixedColorToBob(NextStepCallback cb) {
<span class="nc" id="L479">		this.model.mixAlicePrivateAndPublic();</span>
<span class="nc" id="L480">		this.setColorNextToSend(this.model.getAliceMixedColor());</span>
<span class="nc" id="L481">		this.sendToBob(cb, true, &quot;MA&quot;);</span>
<span class="nc" id="L482">	}</span>
	
	/**
	 * send bob mixed color to alice
	 * @param cb our callback to call, when finished
	 */
	public void sendBobMixedColorToAlice(NextStepCallback cb) {
<span class="nc" id="L489">		this.model.mixBobPrivateAndPublic();</span>
<span class="nc" id="L490">		this.setColorNextToSend(this.model.getBobMixedColor());</span>
<span class="nc" id="L491">		this.sendToAlice(cb, true, &quot;MB&quot;);</span>
<span class="nc" id="L492">	}</span>
	
	/**
	 * mix alice final secret
	 * @param cb our callback to call, when finished
	 */
	public void mixAliceFinalSecret(NextStepCallback cb) {
<span class="nc bnc" id="L499" title="All 4 branches missed.">		assert(model.getBobMixedColor() != null);</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">		assert(model.getAlicePrivateColor() != null);</span>
<span class="nc" id="L501">		this.cm1.setComputeFinalMix(true);</span>
<span class="nc" id="L502">		this.cm1.setEllipColor(0, model.getBobMixedColor());</span>
<span class="nc" id="L503">		this.cm1.setEllipColor(1, model.getAlicePrivateColor());</span>
<span class="nc" id="L504">		this.cm1.mixColors(true, false, cb);</span>
<span class="nc" id="L505">	}</span>
	
	/**
	 * mix bob final secret
	 * @param cb our callback to call, when finished
	 */
	public void mixBobFinalSecret(NextStepCallback cb) {
<span class="nc bnc" id="L512" title="All 4 branches missed.">		assert(model.getAliceMixedColor() != null);</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">		assert(model.getBobPrivateColor() != null);</span>
<span class="nc" id="L514">		this.cm2.setComputeFinalMix(true);</span>
<span class="nc" id="L515">		this.cm2.setEllipColor(0, model.getAliceMixedColor());</span>
<span class="nc" id="L516">		this.cm2.setEllipColor(1, model.getBobPrivateColor());</span>
<span class="nc" id="L517">		this.cm2.mixColors(true, false, cb);</span>
<span class="nc" id="L518">	}</span>
	
	/**
	 * returns true, if sending should
	 * be priodically repeated
	 * @return true if repeat, else false
	 */
	public boolean isRepeat() {
<span class="nc" id="L526">		return repeatPeriodically;</span>
	}

	/**
	 * set the repeat value
	 * @param repeat or not
	 */
	public void setRepeat(boolean repeat) {
<span class="nc" id="L534">		this.repeatPeriodically = repeat;</span>
<span class="nc" id="L535">	}</span>
	
	/**
	 * get the next color to send
	 * @return the color next to send
	 */
	public Color getColor() {
<span class="nc" id="L542">		return colorNextToSend;</span>
	}

	/**
	 * let the user of this class
	 * choose the color to send
	 * @param 
	 */
	public void setColorNextToSend(Color color) {
<span class="nc" id="L551">		this.colorNextToSend = color;</span>
<span class="nc" id="L552">	}</span>
	
	/**
	 * if true the send colors are
	 * kept at the receivers
	 * @return true if we keep colors, else false
	 */
	public boolean isKeepColor() {
<span class="nc" id="L560">		return keepCircles;</span>
	}

	/**
	 * set if we should keep the
	 * next sent colors
	 * @param keep color yes or no
	 */
	public void setKeepColor(boolean keepColor) {
<span class="nc" id="L569">		this.keepCircles = keepColor;</span>
<span class="nc" id="L570">	}</span>

	/**
	 * get the public color
	 * @return the public color
	 */
	public Color getPublicColor() {
<span class="nc" id="L577">		return this.model.getPublicColor();</span>
	}

	/**
	 * get alices private color
	 * @return alices private color
	 */
	public Color getAlicePrivateColor() {
<span class="nc" id="L585">		return this.model.getAlicePrivateColor();</span>
	}
	
	/**
	 * get alices mixed color
	 * @return alices mixed color
	 */
	public Color getAliceMixedColor() {
<span class="nc" id="L593">		return this.model.getAliceMixedColor();</span>
	}
	
	/**
	 * get bobs private color
	 * @return bobs private color
	 */
	public Color getBobPrivateColor() {
<span class="nc" id="L601">		return this.model.getBobPrivateColor();</span>
	}

	/**
	 * get bobs mixed color
	 * @return bobs mixed color if it was computed
	 */
	public Color getBobMixedColor() {
<span class="nc" id="L609">		return this.model.getBobMixedColor();</span>
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span>test (Mar 21, 2014 6:54:09 PM)</div></body></html>